// Taildown Interactive Components
// Generated by Taildown compiler
// Total size: ~6.15KB

(function() {
  'use strict';

  console.log('[Taildown] JavaScript loaded');

  // Initialize all components when DOM is ready
  if (document.readyState === 'loading') {
    console.log('[Taildown] Waiting for DOMContentLoaded');
    document.addEventListener('DOMContentLoaded', init);
  } else {
    console.log('[Taildown] DOM already ready, initializing now');
    init();
  }

  function init() {
    console.log('[Taildown] Initializing interactive components');
    // Tabs Component
    const tabElements = getComponents('tabs');
    console.log('[Taildown Tabs] Found', tabElements.length, 'tabs components');
    tabElements.forEach(tabs => {
      console.log('[Taildown Tabs] Initializing tabs component', tabs);
      const tabList = tabs.querySelector('[role="tablist"]');
      console.log('[Taildown Tabs] Tab list:', tabList);
      if (!tabList) {
        console.warn('[Taildown Tabs] No tablist found, skipping');
        return;
      }
      
      const tabButtons = Array.from(tabList.querySelectorAll('[role="tab"]'));
      console.log('[Taildown Tabs] Found', tabButtons.length, 'tab buttons');
      const tabPanels = Array.from(tabs.querySelectorAll('[role="tabpanel"]'));
      console.log('[Taildown Tabs] Found', tabPanels.length, 'tab panels');
      
      // Set initial active tab
      let activeIndex = tabButtons.findIndex(btn => btn.getAttribute('aria-selected') === 'true');
      console.log('[Taildown Tabs] Initial active index:', activeIndex);
      if (activeIndex === -1) activeIndex = 0;
      
      // Switch to tab
      function switchTab(index) {
        // Update buttons
        tabButtons.forEach((btn, i) => {
          const isActive = i === index;
          btn.setAttribute('aria-selected', isActive);
          btn.setAttribute('tabindex', isActive ? '0' : '-1');
          toggleClass(btn, 'active', isActive);
        });
        
        // Update panels
        tabPanels.forEach((panel, i) => {
          const isActive = i === index;
          panel.hidden = !isActive;
          toggleClass(panel, 'active', isActive);
        });
        
        activeIndex = index;
      }
      
      // Click handlers
      console.log('[Taildown Tabs] Attaching click handlers to', tabButtons.length, 'buttons');
      tabButtons.forEach((btn, index) => {
        console.log('[Taildown Tabs] Attaching handler to button', index);
        btn.addEventListener('click', () => {
          console.log('[Taildown Tabs] Tab clicked:', index);
          switchTab(index);
        });
      });
      console.log('[Taildown Tabs] Click handlers attached');
      
      // Keyboard navigation
      tabList.addEventListener('keydown', (e) => {
        let newIndex = activeIndex;
        
        if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          newIndex = activeIndex > 0 ? activeIndex - 1 : tabButtons.length - 1;
          e.preventDefault();
        } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          newIndex = activeIndex < tabButtons.length - 1 ? activeIndex + 1 : 0;
          e.preventDefault();
        } else if (e.key === 'Home') {
          newIndex = 0;
          e.preventDefault();
        } else if (e.key === 'End') {
          newIndex = tabButtons.length - 1;
          e.preventDefault();
        }
        
        if (newIndex !== activeIndex) {
          switchTab(newIndex);
          tabButtons[newIndex].focus();
        }
      });
      
      // Initialize
      switchTab(activeIndex);
    });

    // Accordion Component
    getComponents('accordion').forEach(accordion => {
      const items = Array.from(accordion.querySelectorAll('[data-accordion-item]'));
      
      items.forEach((item, index) => {
        const trigger = item.querySelector('[data-accordion-trigger]');
        const content = item.querySelector('[data-accordion-content]');
        
        if (!trigger || !content) return;
        
        // Set initial state - first item open by default
        const isOpen = index === 0 || item.hasAttribute('data-open');
        content.hidden = !isOpen;
        trigger.setAttribute('aria-expanded', String(isOpen));
        toggleClass(item, 'open', isOpen);
        
        // Toggle function
        function toggle() {
          const willOpen = content.hidden;
          
          // Toggle current item
          content.hidden = !willOpen;
          trigger.setAttribute('aria-expanded', String(willOpen));
          toggleClass(item, 'open', willOpen);
        }
        
        // Click handler
        trigger.addEventListener('click', toggle);
        
        // Keyboard handler
        trigger.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggle();
          }
        });
      });
    });

    // Carousel Component
    getComponents('carousel').forEach(carousel => {
      const track = carousel.querySelector('[data-carousel-track]');
      const slides = Array.from(carousel.querySelectorAll('[data-carousel-slide]'));
      const prevBtn = carousel.querySelector('[data-carousel-prev]');
      const nextBtn = carousel.querySelector('[data-carousel-next]');
      const indicators = Array.from(carousel.querySelectorAll('[data-carousel-indicator]'));
      
      if (!track || slides.length === 0) return;
      
      let currentIndex = 0;
      let autoPlayInterval = null;
      const autoPlay = carousel.hasAttribute('data-autoplay');
      const interval = parseInt(carousel.getAttribute('data-interval')) || 5000;
      
      // Go to slide
      function goToSlide(index) {
        // Wrap around
        if (index < 0) index = slides.length - 1;
        if (index >= slides.length) index = 0;
        
        currentIndex = index;
        
        // Update slides - hide all except current
        slides.forEach((slide, i) => {
          const isActive = i === index;
          toggleClass(slide, 'active', isActive);
          slide.hidden = !isActive;
          slide.setAttribute('aria-hidden', !isActive);
        });
        
        // Update indicators
        indicators.forEach((indicator, i) => {
          const isActive = i === index;
          toggleClass(indicator, 'active', isActive);
          indicator.setAttribute('aria-current', isActive ? 'true' : 'false');
          
          // Update indicator width for active state
          if (isActive) {
            indicator.style.width = '2rem';
            indicator.style.backgroundColor = 'rgb(17 24 39)';
          } else {
            indicator.style.width = '0.5rem';
            indicator.style.backgroundColor = 'rgb(156 163 175)';
          }
        });
        
        // Update buttons (enable/disable based on position if not looping)
        if (prevBtn) prevBtn.disabled = false;
        if (nextBtn) nextBtn.disabled = false;
      }
      
      // Navigation
      function prev() {
        goToSlide(currentIndex - 1);
      }
      
      function next() {
        goToSlide(currentIndex + 1);
      }
      
      // Button handlers
      if (prevBtn) prevBtn.addEventListener('click', prev);
      if (nextBtn) nextBtn.addEventListener('click', next);
      
      // Indicator handlers
      indicators.forEach((indicator, index) => {
        indicator.addEventListener('click', () => goToSlide(index));
      });
      
      // Keyboard navigation
      carousel.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
          prev();
          e.preventDefault();
        } else if (e.key === 'ArrowRight') {
          next();
          e.preventDefault();
        }
      });
      
      // Touch swipe support
      let touchStartX = 0;
      let touchEndX = 0;
      
      carousel.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
      }, { passive: true });
      
      carousel.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        const diff = touchStartX - touchEndX;
        
        if (Math.abs(diff) > 50) {
          if (diff > 0) next();
          else prev();
        }
      }, { passive: true });
      
      // Auto-play
      if (autoPlay) {
        autoPlayInterval = setInterval(next, interval);
        
        // Pause on hover
        carousel.addEventListener('mouseenter', () => {
          clearInterval(autoPlayInterval);
        });
        
        carousel.addEventListener('mouseleave', () => {
          autoPlayInterval = setInterval(next, interval);
        });
      }
      
      // Initialize
      goToSlide(0);
    });

    // Modal Component
    // Find all modal trigger buttons
    document.querySelectorAll('[data-modal-trigger]').forEach(trigger => {
      const modalId = trigger.getAttribute('data-modal-trigger');
      const modal = document.getElementById(modalId);
      
      if (!modal) return;
      
      const closeButtons = modal.querySelectorAll('[data-modal-close]');
      const backdrop = modal;
      
      let isOpen = false;
      let previousFocus = null;
      
      // Open modal
      function open() {
        if (isOpen) return;
        
        previousFocus = document.activeElement;
        isOpen = true;
        modal.hidden = false;
        modal.setAttribute('aria-hidden', 'false');
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // Fade in animation
        requestAnimationFrame(() => {
          modal.style.opacity = '1';
        });
        
        // Focus first focusable element (skip close button)
        const focusable = modal.querySelectorAll('button:not([data-modal-close]), [href], input, select, textarea');
        if (focusable.length > 0) {
          setTimeout(() => focusable[0].focus(), 100);
        }
      }
      
      // Close modal
      function close() {
        if (!isOpen) return;
        
        isOpen = false;
        modal.style.opacity = '0';
        
        setTimeout(() => {
          modal.hidden = true;
          modal.setAttribute('aria-hidden', 'true');
          modal.style.display = 'none';
          document.body.style.overflow = '';
          
          // Restore focus
          if (previousFocus) {
            previousFocus.focus();
            previousFocus = null;
          }
        }, 200);
      }
      
      // Trigger button click
      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        open();
      });
      
      // Close buttons
      closeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          close();
        });
      });
      
      // Backdrop click
      backdrop.addEventListener('click', (e) => {
        if (e.target === backdrop) {
          close();
        }
      });
      
      // Escape key
      document.addEventListener('keydown', (e) => {
        if (isOpen && e.key === 'Escape') {
          close();
        }
      });
      
      // Initialize
      modal.hidden = true;
      modal.setAttribute('aria-hidden', 'true');
      modal.style.display = 'none';
      modal.style.opacity = '0';
      modal.style.transition = 'opacity 200ms ease-in-out';
    });

    // Tooltip Component
    getComponents('tooltip').forEach(wrapper => {
      const trigger = wrapper.querySelector('[data-tooltip-trigger]');
      const tooltip = wrapper.querySelector('[data-tooltip-content]');
      
      if (!trigger || !tooltip) return;
      
      let isVisible = false;
      let hideTimeout = null;
      
      // Show tooltip
      function show() {
        if (isVisible) return;
        
        clearTimeout(hideTimeout);
        isVisible = true;
        tooltip.hidden = false;
        tooltip.style.display = 'block';
        
        // Fade in
        requestAnimationFrame(() => {
          tooltip.style.opacity = '1';
        });
        
        const tooltipId = 'tooltip-' + Math.random().toString(36).substr(2, 9);
        tooltip.id = tooltipId;
        trigger.setAttribute('aria-describedby', tooltipId);
      }
      
      // Hide tooltip
      function hide() {
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
          isVisible = false;
          tooltip.style.opacity = '0';
          
          setTimeout(() => {
            tooltip.hidden = true;
            tooltip.style.display = 'none';
          }, 200);
          
          trigger.removeAttribute('aria-describedby');
        }, 100);
      }
      
      // Mouse events
      trigger.addEventListener('mouseenter', show);
      trigger.addEventListener('mouseleave', hide);
      
      // Focus events
      trigger.addEventListener('focus', show);
      trigger.addEventListener('blur', hide);
      
      // Touch support for mobile
      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        if (isVisible) {
          hide();
        } else {
          show();
        }
      });
      
      // Initialize as hidden
      tooltip.hidden = true;
      tooltip.style.display = 'none';
      tooltip.style.opacity = '0';
    });
    console.log('[Taildown] Initialization complete');
  }

  // Utility: Get all elements with data-component attribute
  function getComponents(name) {
    return document.querySelectorAll(`[data-component="${name}"]`);
  }

  // Utility: Toggle class on element
  function toggleClass(el, className, force) {
    el.classList.toggle(className, force);
  }

  // Utility: Set multiple attributes
  function setAttrs(el, attrs) {
    for (const [key, value] of Object.entries(attrs)) {
      el.setAttribute(key, value);
    }
  }
})();
