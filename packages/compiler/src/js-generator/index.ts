/**
 * JavaScript Generator for Taildown
 * 
 * Generates minimal, tree-shaken vanilla JS for interactive components.
 * Only includes code for components actually used in the document.
 * 
 * Philosophy:
 * - Clean, readable ES6+ code
 * - Event delegation for performance
 * - Data attributes for targeting
 * - CSS classes for state management
 * - Minimal footprint (~2-5KB for full-featured pages)
 */

import { tabsBehavior } from './behaviors/tabs';
import { accordionBehavior } from './behaviors/accordion';
import { modalBehavior } from './behaviors/modal';
import { tooltipBehavior } from './behaviors/tooltip';
import { carouselBehavior } from './behaviors/carousel';
import { scrollAnimationsBehavior } from './behaviors/scroll-animations';
import { copyCodeBehavior } from './behaviors/copy-code';
import { darkModeBehavior } from './behaviors/dark-mode';
import { navbarBehavior } from './behaviors/navbar';
import { tableBehavior } from './behaviors/table';
import { imageCompareBehavior } from './behaviors/image-compare';
import { diffBehavior } from './behaviors/diff';
import { footnoteBehavior } from './behaviors/footnote';
import { taskListBehavior } from './behaviors/task-list';

/**
 * Component behavior definition
 */
export interface ComponentBehavior {
  /** Component name (matches data-component attribute) */
  name: string;
  /** Vanilla JS code to initialize this component */
  code: string;
  /** Estimated size in bytes */
  size: number;
}

/**
 * Registry of all available component behaviors
 */
const BEHAVIORS: Map<string, ComponentBehavior> = new Map([
  ['tabs', tabsBehavior],
  ['accordion', accordionBehavior],
  ['modal', modalBehavior],
  ['tooltip', tooltipBehavior],
  ['carousel', carouselBehavior],
  ['navbar', navbarBehavior],
  ['table', tableBehavior],
  ['compare-images', imageCompareBehavior],
  ['diff', diffBehavior],
  ['footnotes', footnoteBehavior],
  ['task-list', taskListBehavior],
  ['scroll-animations', scrollAnimationsBehavior],
  ['copy-code', copyCodeBehavior],
  ['dark-mode', darkModeBehavior],
]);

/**
 * Generate JavaScript code for the given components
 * Only includes code for components that are actually used
 * 
 * @param usedComponents - Set of component names used in the document
 * @returns Minified JavaScript code string
 */
export function generateJavaScript(usedComponents: Set<string>, includeDarkMode: boolean = true): string {
  const behaviors: ComponentBehavior[] = [];
  
  // Always include dark mode by default
  if (includeDarkMode) {
    usedComponents.add('dark-mode');
  }
  
  // Tree-shake: only include behaviors for components actually used
  for (const componentName of usedComponents) {
    const behavior = BEHAVIORS.get(componentName);
    if (behavior) {
      behaviors.push(behavior);
    }
  }
  
  // If no interactive components, return empty string
  if (behaviors.length === 0) {
    return '';
  }
  
  // Build the JavaScript output
  const code = buildJavaScript(behaviors);
  
  return code;
}

/**
 * Build the complete JavaScript file
 * Wraps behaviors in DOMContentLoaded and adds utilities
 */
function buildJavaScript(behaviors: ComponentBehavior[]): string {
  // Separate dark mode from other behaviors - it needs to run immediately
  const darkModeBehavior = behaviors.find(b => b.name === 'dark-mode');
  const otherBehaviors = behaviors.filter(b => b.name !== 'dark-mode');
  
  const otherBehaviorCode = otherBehaviors.map(b => b.code).join('\n\n');
  
  let script = `// Taildown Interactive Components
// Generated by Taildown compiler
// Total size: ~${calculateSize(behaviors)}KB

(function() {
  'use strict';

  console.log('[Taildown] JavaScript loaded');
`;

  // Dark mode runs immediately, outside of init()
  if (darkModeBehavior) {
    script += `
  // Dark Mode - runs immediately to prevent flash
${indent(darkModeBehavior.code, 2)}

`;
  }

  // Other behaviors run on DOMContentLoaded
  if (otherBehaviors.length > 0) {
    script += `
  // Initialize all components when DOM is ready
  if (document.readyState === 'loading') {
    console.log('[Taildown] Waiting for DOMContentLoaded');
    document.addEventListener('DOMContentLoaded', init);
  } else {
    console.log('[Taildown] DOM already ready, initializing now');
    init();
  }

  function init() {
    console.log('[Taildown] Initializing interactive components');
${indent(otherBehaviorCode, 4)}
    console.log('[Taildown] Initialization complete');
  }
`;
  }

  script += `
  // Utility: Get all elements with data-component attribute
  function getComponents(name) {
    return document.querySelectorAll(\`[data-component="\${name}"]\`);
  }

  // Utility: Toggle class on element
  function toggleClass(el, className, force) {
    el.classList.toggle(className, force);
  }

  // Utility: Set multiple attributes
  function setAttrs(el, attrs) {
    for (const [key, value] of Object.entries(attrs)) {
      el.setAttribute(key, value);
    }
  }
})();
`;

  return script;
}

/**
 * Indent code by specified spaces
 */
function indent(code: string, spaces: number): string {
  const prefix = ' '.repeat(spaces);
  return code.split('\n').map(line => line ? prefix + line : line).join('\n');
}

/**
 * Calculate total size of behaviors in KB
 */
function calculateSize(behaviors: ComponentBehavior[]): string {
  const bytes = behaviors.reduce((sum, b) => sum + b.size, 0);
  return (bytes / 1024).toFixed(2);
}

/**
 * Get list of all available interactive components
 */
export function getInteractiveComponents(): string[] {
  return Array.from(BEHAVIORS.keys());
}

/**
 * Check if a component has interactive behavior
 */
export function hasInteractiveBehavior(componentName: string): boolean {
  return BEHAVIORS.has(componentName);
}


