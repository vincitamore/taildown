<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Taildown Live Editor</title>
  
  <!-- Modern Monospace Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;0,500;0,600;1,400&display=swap" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Colors - Professional palette */
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #f1f5f9;
      --bg-toolbar: linear-gradient(to bottom, #ffffff, #f8fafc);
      --text-primary: #0f172a;
      --text-secondary: #64748b;
      --text-tertiary: #94a3b8;
      --border-color: #e2e8f0;
      --border-hover: #cbd5e1;
      
      /* Accent colors - Modern blue */
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --accent-light: #dbeafe;
      --accent-glow: rgba(59, 130, 246, 0.2);
      
      /* Status colors */
      --success: #10b981;
      --success-light: #d1fae5;
      --error: #ef4444;
      --error-light: #fee2e2;
      --warning: #f59e0b;
      --warning-light: #fef3c7;
      
      /* Shadows - Layered depth */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      
      /* Transitions */
      --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);
      
      /* Typography */
      --font-mono: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
      --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    }

    /* Dark Mode - Using softer, more readable colors */
    [data-theme="dark"] {
      --bg-primary: #1e1e2e;
      --bg-secondary: #181825;
      --bg-tertiary: #2a2a3a;
      --text-primary: #cdd6f4;
      --text-secondary: #bac2de;
      --text-tertiary: #7f849c;
      --border-color: #45475a;
      --accent: #89b4fa;
      --accent-hover: #b4befe;
      --accent-light: rgba(137, 180, 250, 0.12);
      --accent-glow: rgba(137, 180, 250, 0.3);
      
      --success: #a6e3a1;
      --success-light: rgba(166, 227, 161, 0.12);
      --error: #f38ba8;
      --error-light: rgba(243, 139, 168, 0.12);
      --warning: #f9e2af;
      --warning-light: rgba(249, 226, 175, 0.12);
      
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.5);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.6), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
    }

    /* Dark mode component overrides */
    [data-theme="dark"] #toolbar {
      background: rgba(30, 30, 46, 0.95);
      border-bottom-color: var(--border-color);
    }

    [data-theme="dark"] #slash-menu,
    [data-theme="dark"] #bubble-menu,
    [data-theme="dark"] .cm-tooltip-autocomplete {
      background: var(--bg-tertiary) !important;
      border-color: var(--border-color) !important;
    }

    [data-theme="dark"] .slash-menu-item:hover,
    [data-theme="dark"] .slash-menu-item.selected,
    [data-theme="dark"] .bubble-menu-button:hover,
    [data-theme="dark"] .cm-tooltip-autocomplete > ul > li:hover,
    [data-theme="dark"] .cm-tooltip-autocomplete > ul > li[aria-selected] {
      background: var(--accent-light) !important;
    }

    [data-theme="dark"] .bubble-menu-button:active {
      background: var(--accent) !important;
    }

    [data-theme="dark"] #editor-pane {
      background: var(--bg-primary);
      border-right-color: var(--border-color);
    }

    [data-theme="dark"] .cm-editor {
      background: var(--bg-primary);
      color: var(--text-primary);
    }
    
    [data-theme="dark"] .cm-cursor,
    [data-theme="dark"] .cm-cursor-primary {
      border-left-color: #ffffff !important;
    }
    
    [data-theme="dark"] .cm-content {
      caret-color: #ffffff !important;
    }

    [data-theme="dark"] .cm-gutters {
      background: var(--bg-secondary);
      border-right-color: var(--border-color);
      color: var(--text-tertiary);
    }

    [data-theme="dark"] .cm-activeLineGutter {
      background: var(--accent-light);
      color: var(--accent);
    }

    [data-theme="dark"] .cm-activeLine {
      background: rgba(137, 180, 250, 0.08) !important;
    }

    [data-theme="dark"] #divider {
      background: var(--border-color);
    }

    [data-theme="dark"] #preview-frame {
      background: var(--bg-primary);
    }

    [data-theme="dark"] #loading {
      background: rgba(30, 30, 46, 0.95);
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-secondary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Toolbar - Premium glass effect */
    #toolbar {
      background: var(--bg-toolbar);
      border-bottom: 1px solid var(--border-color);
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
      height: 56px;
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow-sm);
      z-index: 10;
    }

    #toolbar button {
      position: relative;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 18px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: -0.01em;
      transition: all var(--transition-base);
      box-shadow: var(--shadow-sm);
    }

    #toolbar button:hover {
      background: var(--accent-light);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    #toolbar button:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
      background: var(--bg-secondary);
    }

    #toolbar button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #toolbar button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    #toolbar button:disabled:hover {
      background: var(--bg-primary);
      border-color: var(--border-color);
      box-shadow: var(--shadow-sm);
      transform: none;
    }

    /* Help button - styled as icon button */
    #help-btn {
      width: 36px;
      height: 36px;
      padding: 0;
      border-radius: 50%;
      font-size: 18px;
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-light);
      border-color: var(--accent);
      color: var(--accent);
    }

    #help-btn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent-hover);
    }

    #filename-display {
      color: var(--text-secondary);
      font-size: 14px;
      margin-left: 4px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      font-weight: 600;
      font-family: var(--font-mono);
      letter-spacing: -0.02em;
      border: 1px solid transparent;
      transition: all var(--transition-base);
    }

    #filename-display:hover {
      border-color: var(--border-hover);
      color: var(--text-primary);
    }

    #status {
      margin-left: auto;
      color: var(--text-secondary);
      font-size: 13px;
      padding: 6px 14px;
      border-radius: 6px;
      font-weight: 500;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      transition: all var(--transition-base);
      font-family: var(--font-mono);
      letter-spacing: -0.01em;
    }

    #status.success {
      color: var(--success);
      background: var(--success-light);
      border-color: var(--success);
    }

    #status.error {
      color: var(--error);
      background: var(--error-light);
      border-color: var(--error);
    }

    /* Editor container */
    #editor-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
      background: var(--bg-secondary);
    }

    #editor-pane {
      flex: 1;
      overflow: auto;
      background: var(--bg-primary);
      border-right: 1px solid var(--border-color);
      position: relative;
    }

    #preview-pane {
      flex: 1;
      overflow: hidden;
      background: var(--bg-tertiary);
      display: flex;
      flex-direction: column;
      position: relative;
    }

    /* Draggable divider - Enhanced */
    #divider {
      width: 5px;
      background: var(--border-color);
      cursor: col-resize;
      flex-shrink: 0;
      transition: all var(--transition-fast);
      position: relative;
      z-index: 5;
    }

    #divider::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 3px;
      height: 40px;
      background: var(--border-hover);
      border-radius: 999px;
      opacity: 0;
      transition: opacity var(--transition-base);
    }

    #divider:hover {
      background: var(--accent-light);
    }

    #divider:hover::before {
      opacity: 1;
      background: var(--accent);
    }

    #divider.dragging {
      background: var(--accent);
    }

    #divider.dragging::before {
      opacity: 1;
      background: white;
    }

    #preview-frame {
      width: 100%;
      height: 100%;
      border: none;
      background: white;
      border-radius: 0;
    }

    /* CodeMirror styling enhancements */
    .cm-editor {
      height: 100%;
      font-size: 15px;
      line-height: 1.8;
      font-family: var(--font-mono);
      font-weight: 400;
      letter-spacing: 0.01em;
    }

    .cm-scroller {
      overflow: auto;
      font-feature-settings: 'liga' 1, 'calt' 1, 'ss01' 1, 'ss02' 1;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
      padding: 20px 0;
    }

    .cm-content {
      padding: 0 20px;
    }

    .cm-gutters {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      color: var(--text-tertiary);
      padding: 0 12px;
      font-size: 13px;
      font-variant-numeric: tabular-nums;
    }

    .cm-activeLineGutter {
      background: var(--accent-light);
      color: var(--accent);
      font-weight: 600;
    }

    .cm-line {
      padding-left: 4px;
    }

    .cm-activeLine {
      background: var(--accent-light) !important;
    }

    .cm-content {
      padding: 16px 0;
    }

    .cm-line {
      padding: 0 16px;
    }

    /* Loading indicator - Premium design */
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 32px 40px;
      border-radius: 16px;
      box-shadow: var(--shadow-xl);
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 16px;
      border: 1px solid var(--border-color);
      backdrop-filter: blur(8px);
    }

    #loading.hidden {
      display: none;
    }

    #loading span {
      font-weight: 600;
    }

    /* Slash Command Menu */
    #slash-menu {
      position: absolute;
      z-index: 1000;
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: var(--shadow-xl);
      max-width: 320px;
      max-height: 400px;
      overflow-y: auto;
      display: none;
    }

    #slash-menu.active {
      display: block;
    }

    .slash-menu-item {
      padding: 10px 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid var(--border-color);
      transition: background var(--transition-fast);
    }

    .slash-menu-item:last-child {
      border-bottom: none;
    }

    .slash-menu-item:hover,
    .slash-menu-item.selected {
      background: var(--accent-light);
    }

    .slash-menu-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }

    .slash-menu-content {
      flex: 1;
    }

    .slash-menu-title {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .slash-menu-desc {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .slash-menu-kbd {
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text-tertiary);
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
    }

    /* Smart Autocomplete Styling */
    .cm-tooltip-autocomplete {
      background: white !important;
      border: 1px solid var(--border-color) !important;
      border-radius: 8px !important;
      box-shadow: var(--shadow-xl) !important;
      padding: 0 !important;
      font-family: var(--font-sans) !important;
      max-height: 400px !important;
      overflow-y: auto !important;
    }

    .cm-tooltip-autocomplete > ul {
      margin: 0 !important;
      padding: 0 !important;
      list-style: none !important;
    }

    .cm-tooltip-autocomplete > ul > li {
      padding: 10px 14px !important;
      cursor: pointer !important;
      display: flex !important;
      align-items: center !important;
      gap: 12px !important;
      border-bottom: 1px solid var(--border-color) !important;
      transition: background var(--transition-fast) !important;
      font-size: 14px !important;
    }

    .cm-tooltip-autocomplete > ul > li:last-child {
      border-bottom: none !important;
    }

    .cm-tooltip-autocomplete > ul > li[aria-selected] {
      background: var(--accent-light) !important;
    }

    .cm-tooltip-autocomplete > ul > li:hover {
      background: var(--accent-light) !important;
    }

    /* Autocomplete icon preview */
    .autocomplete-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .autocomplete-label {
      flex: 1;
      font-weight: 500;
      color: var(--text-primary);
    }

    .autocomplete-info {
      font-size: 12px;
      color: var(--text-secondary);
      margin-left: auto;
      padding-left: 12px;
    }

    .autocomplete-type {
      font-size: 11px;
      color: var(--text-tertiary);
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: var(--font-mono);
    }

    /* Bubble Menu */
    #bubble-menu {
      position: absolute;
      z-index: 1001;
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: var(--shadow-xl);
      padding: 4px;
      display: none;
      gap: 2px;
    }

    #bubble-menu.active {
      display: flex;
    }

    .bubble-menu-button {
      width: 32px;
      height: 32px;
      border: none;
      background: transparent;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background var(--transition-fast);
      color: var(--text-primary);
    }

    .bubble-menu-button:hover {
      background: var(--accent-light);
    }

    .bubble-menu-button:active {
      background: var(--accent);
      color: white;
    }

    .bubble-menu-divider {
      width: 1px;
      height: 24px;
      background: var(--border-color);
      margin: 0 4px;
    }
      color: var(--text-primary);
      font-size: 15px;
    }

    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--accent-light);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Smooth fade-in animation */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #toolbar, #editor-container {
      animation: fadeIn 0.3s ease-out;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-hover);
      border-radius: 6px;
      border: 3px solid var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-tertiary);
    }

    /* Focus styles for accessibility */
    *:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    /* Responsive: Stack vertically on small screens */
    @media (max-width: 768px) {
      #editor-container {
        flex-direction: column;
      }

      #editor-pane {
        border-right: none;
        border-bottom: 1px solid var(--border-color);
      }

      #divider {
        width: 100%;
        height: 5px;
        cursor: row-resize;
      }

      #divider::before {
        width: 40px;
        height: 3px;
      }

      #toolbar {
        flex-wrap: wrap;
        height: auto;
        padding: 12px;
        gap: 8px;
      }

      #toolbar button {
        font-size: 13px;
        padding: 7px 14px;
      }

      #filename-display,
      #status {
        font-size: 12px;
      }
    }

    /* Print styles */
    @media print {
      #toolbar, #editor-pane, #divider {
        display: none !important;
      }
      #preview-pane {
        overflow: visible;
      }
    }

    /* High contrast mode support */
    @media (prefers-contrast: high) {
      :root {
        --border-color: #94a3b8;
        --text-secondary: #475569;
      }
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <span>Loading Taildown Editor...</span>
  </div>

  <!-- Slash Command Menu -->
  <div id="slash-menu"></div>

  <!-- Bubble Menu -->
  <div id="bubble-menu">
    <button class="bubble-menu-button" data-action="bold" title="Bold (Ctrl+B)"></button>
    <button class="bubble-menu-button" data-action="italic" title="Italic (Ctrl+I)"></button>
    <button class="bubble-menu-button" data-action="code" title="Code"></button>
    <div class="bubble-menu-divider"></div>
    <button class="bubble-menu-button" data-action="heading" title="Heading"></button>
    <button class="bubble-menu-button" data-action="link" title="Link (Ctrl+K)"></button>
  </div>

  <div id="toolbar">
    <button id="new-btn" title="Create new document (Ctrl+N)">New</button>
    <button id="open-btn" title="Open file (Ctrl+O)">Open</button>
    <button id="save-btn" title="Save file (Ctrl+S)">Save</button>
    <button id="download-btn" title="Download .td file">Download</button>
    <button id="export-btn" title="Export HTML (Ctrl+E)">Export HTML</button>
    <button id="help-btn" title="Show welcome template">?</button>
    <button id="theme-toggle-btn" title="Toggle dark mode" style="margin-left: auto;"></button>
    <span id="filename-display">untitled.td</span>
    <span id="status"></span>
  </div>

  <div id="editor-container">
    <div id="editor-pane"></div>
    <div id="divider"></div>
    <div id="preview-pane">
      <iframe id="preview-frame" sandbox="allow-scripts allow-same-origin"></iframe>
    </div>
  </div>

  <script type="module">
    // Import Taildown bundle from relative path (development)
    // In production build, this will be replaced with an inline data URL
    import * as Taildown from '../packages/compiler/dist/taildown-browser.js';
    
    const {
      compile,
      EditorView,
      EditorState,
      Compartment,
      Prec,
      keymap,
      lineNumbers,
      highlightActiveLineGutter,
      history,
      historyKeymap,
      defaultKeymap,
      indentWithTab,
      searchKeymap,
      highlightSelectionMatches,
      autocompletion,
      startCompletion,
      acceptCompletion,
      closeCompletion,
      moveCompletionSelection,
      closeBrackets,
      closeBracketsKeymap,
      indentOnInput,
      bracketMatching,
      foldGutter,
      foldKeymap,
      lintKeymap,
      taildown,
      taildownHighlightStyle,
      taildownDarkHighlightStyle,
    } = Taildown;

    // Default welcome template
    const DEFAULT_TEMPLATE = `# Welcome to Taildown Live Editor! {huge-bold primary center}

Your modern, offline-capable Markdown editor with superpowers {large muted center}

---

## :icon[zap]{warning} Quick Start Guide

**Try these powerful features:**

1. Type :kbd[/] to open the slash command menu
2. Select text and use the **bubble menu** for formatting
3. Type :kbd[:] for autocomplete (try :kbd[:::], :kbd[:icon], or :kbd[{])
4. Press :kbd[Tab] to accept suggestions
5. Toggle **dark mode** with the moon/sun icon

:::alert {info}
:icon[lightbulb]{warning} **Tip:** All your work is auto-saved to localStorage and the preview updates as you type!
:::

---

## :icon[keyboard]{primary} Slash Commands

Type :kbd[/] anywhere to access quick insert commands:

- **/h1** → Large heading
- **/card** → Card component with auto-fencing
- **/mermaid** → Diagram block
- **/code** → Code block
- **/table** → 2-column table template

Try it now: Type :kbd[/] below this line!



---

## :icon[sparkles]{accent} Smart Autocomplete

Experience intelligent, context-aware suggestions:

**Component Fence:** Type :kbd[:::c] and press :kbd[Tab] to see card, callout, carousel...

**Attributes:** Type :kbd[{] to see 50+ style options:
- **{primary}**, **{secondary}**, **{accent}**
- **{huge-bold}**, **{large-light}**, **{xl-bold}**
- **{light-glass}**, **{elevated}**, **{shadow-xl}**
- **{fade-in}**, **{slide-up}**, **{hover-lift}**

**Icons:** Type :kbd[:icon] to browse 157+ Lucide icons with previews!

---

## :icon[edit]{secondary} Bubble Menu

**Select any text** to see the floating toolbar with quick formatting:
- Bold (Ctrl+B)
- Italic (Ctrl+I)
- Code
- Heading
- Link (Ctrl+K)

---

## :icon[layout]{success} Interactive Components

:::tabs
### Cards & Layouts

:::card {light-glass padded hover-lift}
#### Beautiful Cards {primary}
Cards support titles, icons, and style attributes. Hover over this card!

:icon[heart]{error} :icon[star]{warning} :icon[zap]{primary}
:::

:::grid {3}
:::card {subtle-glass padded center}
:icon[box]{primary}

**Grid Layout**

Responsive grids
:::

:::card {subtle-glass padded center}
:icon[layers]{secondary}

**Stack Items**

Equal heights
:::

:::card {subtle-glass padded center}
:icon[table]{accent}

**Auto-flow**

Smart wrapping
:::
:::

### Mermaid Diagrams

:::mermaid
graph LR
  A[Write] --> B{Compile}
  B -->|Success| C[Preview]
  B -->|Error| D[Debug]
  C --> E[Export HTML]
:::

### Buttons & Modals

:::card {center}

[Click Me](#){button primary modal="Success! This is an inline modal. Click anywhere outside or press Escape to close."}

[Hover Me](#){button secondary tooltip="Tooltips provide helpful context without cluttering your UI"}
:::

:::

---

## :icon[type]{info} Typography & Styling

Make your content **pop** with natural language styles:

# Huge Bold Primary Heading {huge-bold primary}
## Large Bold Secondary {large-bold secondary}  
### Medium Accent Heading {medium accent}

Regular text, **bold text**, *italic text*, and \`inline code\`.


This entire block is styled with multiple attributes!
You can combine size, color, padding, borders, and effects.
{large-bold light-glass padded rounded primary} 

---

## :icon[code-2]{primary} Code Highlighting

Syntax highlighting powered by CodeMirror 6:

${'```'}javascript
function greet(name) {
  console.log('Hello, ' + name + '!');
  return true;
}

greet('Taildown');
${'```'}

${'```'}css
.beautiful {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 12px;
  padding: 2rem;
}
${'```'}

---

## :icon[list]{secondary} Lists & Tables

**Bullet List:**
- First item
- Second item with **bold**
- :icon[check]{success} Third item with a checkmark

**Numbered List:**
1. Step one
2. Step two  
3. Step three

**Table:**

| Feature | Status | Priority |
|---------|--------|----------|
| Slash Commands | :icon[check-circle]{success} | High |
| Autocomplete | :icon[check-circle]{success} | High |
| Dark Mode | :icon[check-circle]{success} | Medium |
{sortable zebra}

---

## :icon[smile]{accent} More Components

:::callout {info}
:icon[info]{info} **Did you know?**  
Callouts are great for tips, warnings, and important information.
:::

:::alert {warning}
:icon[alert-triangle]{warning} **Warning:** This editor is highly addictive. You may never want to use another Markdown editor again!
:::

**Inline Badges:** Project Status: :badge[active]{success} Version: :badge[v0.2.0]{info} License: :badge[MIT]{primary}

---

## :icon[download]{primary} Export & Share

When you're done:

1. **Save** (.td file) - Ctrl+S
2. **Export HTML** - Ctrl+E (production-ready, self-contained)
3. **Download** - Get raw .td file
4. **Share** - All features work offline!

:::card {elevated primary}

### Ready to create something amazing? {huge-bold center}

Start by clearing this template and writing your own content!
{center}

Try the **New** button (Ctrl+N) to start fresh!
{center}

:::

---

Built with :icon[heart]{error} using Taildown • Fully offline-capable • No tracking
{center muted small}
`;

    // State
    let editor;
    let currentFilename = 'untitled.td';
    let currentFileHandle = null;
    let updateTimeout = null;
    let isDragging = false;
    let slashMenuActive = false;
    let slashMenuIndex = 0;
    let slashMenuStart = null;
    let filteredCommands = []; // Track currently filtered commands

    // DOM elements
    const editorPane = document.getElementById('editor-pane');
    const previewFrame = document.getElementById('preview-frame');
    const statusBar = document.getElementById('status');
    const filenameDisplay = document.getElementById('filename-display');
    const divider = document.getElementById('divider');
    const loading = document.getElementById('loading');

    // Buttons
    const newBtn = document.getElementById('new-btn');
    const openBtn = document.getElementById('open-btn');
    const saveBtn = document.getElementById('save-btn');
    const downloadBtn = document.getElementById('download-btn');
    const exportBtn = document.getElementById('export-btn');
    const helpBtn = document.getElementById('help-btn');
    const themeToggleBtn = document.getElementById('theme-toggle-btn');
    const slashMenu = document.getElementById('slash-menu');
    const bubbleMenu = document.getElementById('bubble-menu');

    // Autocomplete data sources
    const componentNames = [
      'card', 'button', 'alert', 'badge', 'avatar', 'grid', 'container',
      'tabs', 'accordion', 'modal', 'tooltip', 'carousel', 'navbar',
      'tree', 'flow', 'button-group', 'sidebar', 'breadcrumb', 'pagination',
      'progress', 'skeleton', 'callout', 'mermaid'
    ];

    const styleAttributes = [
      // Colors
      'primary', 'secondary', 'accent', 'success', 'warning', 'error', 'info', 'muted',
      // Sizes
      'xs', 'small', 'large', 'xl', '2xl', '3xl', 'huge', 'massive',
      // Weight
      'thin', 'light', 'normal', 'medium', 'semibold', 'bold', 'extra-bold', 'black',
      // Combinations
      'huge-bold', 'large-bold', 'xl-bold', 'small-light',
      // Padding
      'padded', 'padded-sm', 'padded-lg', 'padded-xl',
      // Gaps
      'gap', 'gap-sm', 'gap-lg', 'gap-xl',
      // Line height
      'tight-lines', 'normal-lines', 'relaxed-lines', 'loose-lines',
      // Alignment
      'center', 'left', 'right', 'justify',
      // Display
      'flex', 'grid', 'inline', 'block',
      // Shadows
      'shadow', 'shadow-sm', 'shadow-lg', 'shadow-xl', 'elevated', 'floating',
      // Borders
      'rounded', 'rounded-sm', 'rounded-lg', 'rounded-full',
      // Glass
      'subtle-glass', 'light-glass', 'heavy-glass',
      // Animations
      'fade-in', 'slide-up', 'slide-down', 'slide-left', 'slide-right', 'zoom-in', 'scale-in',
      'hover-lift', 'hover-glow', 'hover-scale', 'interactive',
      // Component variants
      'flat', 'elevated', 'outlined', 'bordered', 'interactive',
      'sm', 'md', 'lg', 'xl'
    ];

    const iconNames = [
      "accessibility", "activity", "alert-circle", "alert-octagon", "alert-triangle",
      "align-center", "align-left", "arrow-down", "arrow-left", "arrow-right", "arrow-up",
      "award", "bar-chart", "beaker", "bell", "bluetooth", "book", "book-open", "bookmark",
      "box", "brackets", "briefcase", "bug", "calendar", "check", "check-circle", "check-square",
      "chevron-right", "chevrons-right", "circle", "clock", "cloud", "code", "code-2", "compass",
      "copy", "cpu", "credit-card", "crown", "database", "dollar-sign", "download", "droplet",
      "edit", "external-link", "eye", "facebook", "feather", "figma", "file", "file-code",
      "file-plus", "file-text", "file-tree", "flag", "flame", "folder", "gauge", "gift",
      "git-branch", "git-commit", "git-fork", "git-pull-request", "github", "globe",
      "graduation-cap", "grid", "grid-3x3", "hand", "hash", "headphones", "heart", "help-circle",
      "highlighter", "home", "image", "info", "key", "keyboard", "layers", "layout", "life-buoy",
      "lightbulb", "link", "linkedin", "list", "loader", "lock", "mail", "map", "maximize",
      "maximize-2", "menu", "message-circle", "message-square", "minimize", "minus", "minus-square",
      "monitor", "moon", "more-horizontal", "mouse-pointer", "move", "music", "package", "palette",
      "panel-left", "party-popper", "play", "play-circle", "plus", "refresh-cw", "rocket", "search",
      "server", "settings", "share", "share-2", "shield", "shopping-bag", "shopping-cart",
      "smartphone", "smile", "sparkles", "speaker", "square", "square-stack", "star", "sun",
      "table", "tag", "target", "terminal", "test-tube", "thumbs-down", "thumbs-up", "tool",
      "trash", "trending-down", "trending-up", "trophy", "twitter", "type", "upload", "user",
      "user-plus", "users", "video", "wand-2", "wave", "wind", "wrench", "x", "x-circle", "zap"
    ];

    // Helper to create Lucide icon SVG
    function lucideIcon(iconName) {
      // Map of Lucide icons we use (SVG paths from lucide.dev)
      const icons = {
        'type': '<path d="M4 7V4h16v3M9 20h6M12 4v16"/>',
        'heading-1': '<path d="M4 12h8M4 18V6M12 18V6"/><path d="m17 12 3-3 3 3M20 9v12"/>',
        'heading-2': '<path d="M4 12h8M4 18V6M12 18V6"/><path d="M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-2.5"/>',
        'heading-3': '<path d="M4 12h8M4 18V6M12 18V6"/><path d="M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2"/><path d="M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2"/>',
        'bold': '<path d="M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8"/>',
        'italic': '<line x1="19" x2="10" y1="4" y2="4"/><line x1="14" x2="5" y1="20" y2="20"/><line x1="15" x2="9" y1="4" y2="20"/>',
        'code': '<polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/>',
        'code-2': '<path d="m18 16 4-4-4-4"/><path d="m6 8-4 4 4 4"/><path d="m14.5 4-5 16"/>',
        'quote': '<path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"/><path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"/>',
        'list': '<line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/>',
        'list-ordered': '<line x1="10" x2="21" y1="6" y2="6"/><line x1="10" x2="21" y1="12" y2="12"/><line x1="10" x2="21" y1="18" y2="18"/><path d="M4 6h1v4"/><path d="M4 10h2"/><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"/>',
        'link': '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>',
        'image': '<rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>',
        'minus': '<path d="M5 12h14"/>',
        'table': '<path d="M12 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/>',
        'box': '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>',
        'alert-circle': '<circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/>',
        'lightbulb': '<path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/>',
        'layout': '<rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/>',
        'wand-2': '<path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/>',
        'sun': '<circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/>',
        'moon': '<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>',
      };
      
      const path = icons[iconName] || icons['code'];
      return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${path}</svg>`;
    }

    // Slash command registry
    const slashCommands = [
      { name: 'Heading 1', icon: 'heading-1', insert: '# ', description: 'Large heading' },
      { name: 'Heading 2', icon: 'heading-2', insert: '## ', description: 'Medium heading' },
      { name: 'Heading 3', icon: 'heading-3', insert: '### ', description: 'Small heading' },
      { name: 'Bold', icon: 'bold', insert: '****', description: 'Bold text', cursorOffset: -2 },
      { name: 'Italic', icon: 'italic', insert: '**', description: 'Italic text', cursorOffset: -1 },
      { name: 'Code Block', icon: 'code-2', insert: '```\n\n```', description: 'Code with syntax highlighting', cursorOffset: -4 },
      { name: 'Inline Code', icon: 'code', insert: '``', description: 'Inline code', cursorOffset: -1 },
      { name: 'Quote', icon: 'quote', insert: '> ', description: 'Blockquote' },
      { name: 'List', icon: 'list', insert: '- ', description: 'Bullet list' },
      { name: 'Numbered List', icon: 'list-ordered', insert: '1. ', description: 'Numbered list' },
      { name: 'Link', icon: 'link', insert: '[](url)', description: 'Hyperlink', cursorOffset: -5 },
      { name: 'Image', icon: 'image', insert: '![](url)', description: 'Insert image', cursorOffset: -5 },
      { name: 'Divider', icon: 'minus', insert: '\n---\n', description: 'Horizontal rule' },
      { name: 'Table', icon: 'table', insert: '| Header 1 | Header 2 |\n|----------|----------|\n|  |  |', description: '2-column table', cursorOffset: -6 },
      { name: 'Card', icon: 'box', insert: ':::card title=""\n\n:::', description: 'Card component', cursorOffset: -6 },
      { name: 'Alert', icon: 'alert-circle', insert: ':::alert\n\n:::', description: 'Alert box', cursorOffset: -4 },
      { name: 'Callout', icon: 'lightbulb', insert: ':::callout\n\n:::', description: 'Callout box', cursorOffset: -4 },
      { name: 'Button', icon: 'box', insert: ':::button\n\n:::', description: 'Button component', cursorOffset: -4 },
      { name: 'Tabs', icon: 'layout', insert: ':::tabs\n## Tab 1\n\n## Tab 2\n\n:::', description: 'Tabbed interface', cursorOffset: -17 },
      { name: 'Mermaid', icon: 'wand-2', insert: ':::mermaid\ngraph TD\n  A --> B\n:::', description: 'Diagram', cursorOffset: -16 },
    ];

    // Slash command functions
    function showSlashMenu(searchText = '') {
      // Update filtered commands in outer scope
      filteredCommands = slashCommands.filter(cmd => 
        cmd.name.toLowerCase().includes(searchText.toLowerCase())
      );

      if (filteredCommands.length === 0) {
        hideSlashMenu();
        return;
      }

      slashMenuIndex = 0;
      slashMenu.innerHTML = filteredCommands.map((cmd, index) => `
        <div class="slash-menu-item ${index === 0 ? 'selected' : ''}" data-index="${index}">
          <div class="slash-menu-icon">${lucideIcon(cmd.icon)}</div>
          <div class="slash-menu-content">
            <div class="slash-menu-title">${cmd.name}</div>
            <div class="slash-menu-desc">${cmd.description}</div>
          </div>
        </div>
      `).join('');

      // Position menu
      const coords = editor.coordsAtPos(editor.state.selection.main.head);
      if (coords) {
        slashMenu.style.left = `${coords.left}px`;
        slashMenu.style.top = `${coords.bottom + 5}px`;
      }

      slashMenu.classList.add('active');
      slashMenuActive = true;

      // Add click handlers
      slashMenu.querySelectorAll('.slash-menu-item').forEach((item, index) => {
        item.addEventListener('click', () => {
          insertSlashCommand(filteredCommands[index]);
        });
      });
    }

    function hideSlashMenu() {
      slashMenu.classList.remove('active');
      slashMenuActive = false;
      slashMenuStart = null;
      slashMenuIndex = 0;
      filteredCommands = [];
    }

    function navigateSlashMenu(direction) {
      const items = slashMenu.querySelectorAll('.slash-menu-item');
      if (items.length === 0) return;

      items[slashMenuIndex].classList.remove('selected');
      
      if (direction === 'down') {
        slashMenuIndex = (slashMenuIndex + 1) % items.length;
      } else {
        slashMenuIndex = (slashMenuIndex - 1 + items.length) % items.length;
      }
      
      items[slashMenuIndex].classList.add('selected');
      items[slashMenuIndex].scrollIntoView({ block: 'nearest' });
    }

    function insertSlashCommand(command) {
      if (!command || slashMenuStart === null) return;

      const { from, to } = { from: slashMenuStart, to: editor.state.selection.main.head };
      const insert = command.insert;
      const cursorOffset = command.cursorOffset || 0;

      editor.dispatch({
        changes: { from, to, insert },
        selection: { anchor: from + insert.length + cursorOffset }
      });

      hideSlashMenu();
    }

    function executeSelectedCommand() {
      if (filteredCommands.length === 0) return;
      
      // Use the currently selected index from the stored filtered commands
      const command = filteredCommands[slashMenuIndex];
      if (command) {
        insertSlashCommand(command);
      }
    }

    // Helper to render autocomplete items with icons
    function renderAutocompleteItem(label, type, info, iconPreview = null) {
      return (completion) => {
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '12px';
        container.style.width = '100%';
        
        // Icon preview (for icon autocomplete)
        if (iconPreview) {
          const iconDiv = document.createElement('div');
          iconDiv.className = 'autocomplete-icon';
          iconDiv.innerHTML = iconPreview;
          container.appendChild(iconDiv);
        }
        
        // Label
        const labelDiv = document.createElement('div');
        labelDiv.className = 'autocomplete-label';
        labelDiv.textContent = label;
        container.appendChild(labelDiv);
        
        // Info/type badge
        if (info) {
          const infoDiv = document.createElement('div');
          infoDiv.className = 'autocomplete-type';
          infoDiv.textContent = info;
          container.appendChild(infoDiv);
        }
        
        return container;
      };
    }

    // Smart autocomplete extension
    function taildownAutocomplete(context) {
      const word = context.matchBefore(/[\w-]+/);
      const line = context.state.doc.lineAt(context.pos);
      const textBefore = line.text.slice(0, context.pos - line.from);
      
      // Colon trigger - suggest ::: or :icon[
      if (textBefore.endsWith(':') && !textBefore.endsWith('::')) {
        const colonSuggestions = [
          { 
            label: ':::', 
            insert: '::', 
            info: 'component fence',
            retrigger: true
          },
          { 
            label: ':icon[]', 
            insert: 'icon[]', 
            info: 'inline icon',
            retrigger: true,
            cursorOffset: -1  // Place cursor between brackets
          }
        ];
        
        return {
          from: context.pos,
          validFor: /^$/,
          options: colonSuggestions.map(item => ({
            label: item.label,
            type: 'keyword',
            info: item.info,
            render: renderAutocompleteItem(item.label, 'keyword', item.info),
            apply: (view, completion, from, to) => {
              const cursorPos = from + item.insert.length + (item.cursorOffset || 0);
              view.dispatch({
                changes: { from, to, insert: item.insert },
                selection: { anchor: cursorPos }
              });
              // Retrigger autocomplete after insertion
              if (item.retrigger) {
                setTimeout(() => {
                  startCompletion(view);
                }, 10);
              }
            }
          }))
        };
      }
      
      // Component autocomplete - triggered after :::
      if (textBefore.endsWith(':::')) {
        return {
          from: context.pos,
          validFor: /^[\w-]*$/,  // Stay open while typing component names (letters, numbers, dashes)
          options: componentNames.map(name => ({
            label: name,
            type: 'keyword',
            info: 'component',
            render: renderAutocompleteItem(name, 'keyword', 'component'),
            apply: (view, completion, from, to) => {
              // Insert component name, newlines, and closing fence
              const fullInsert = `${name}\n\n:::`;
              const cursorPos = from + name.length + 1; // Position after component name and first newline
              
              view.dispatch({
                changes: { from, to, insert: fullInsert },
                selection: { anchor: cursorPos }
              });
            }
          }))
        };
      }
      
      // Attribute autocomplete - triggered after { or inside {}
      const braceMatch = textBefore.match(/\{([^}]*)$/);
      if (braceMatch) {
        const typed = braceMatch[1];
        const filtered = styleAttributes.filter(attr => 
          attr.toLowerCase().includes(typed.toLowerCase())
        );
        
        return {
          from: context.pos - typed.length,
          validFor: /^[\w-]*$/,  // Stay open while typing attributes
          options: filtered.map(attr => ({
            label: attr,
            type: 'property',
            info: 'style',
            render: renderAutocompleteItem(attr, 'property', 'style'),
            apply: attr
          }))
        };
      }
      
      // Icon autocomplete - triggered after :icon[
      const iconMatch = textBefore.match(/:icon\[([^\]]*)$/);
      if (iconMatch) {
        const typed = iconMatch[1];
        const filtered = iconNames.filter(icon => 
          icon.toLowerCase().includes(typed.toLowerCase())
        );
        
        return {
          from: context.pos - typed.length,
          validFor: /^[\w-]*$/,  // Stay open while typing icon names
          options: filtered.map(icon => {            
            return {
              label: icon,
              type: 'variable',
              info: 'icon',
              render: renderAutocompleteItem(icon, 'variable', 'icon', lucideIcon(getIconPath(icon))),
              apply: icon
            };
          })
        };
      }
      
      // Attribute autocomplete after icon name - :icon[name]{
      const iconAttrMatch = textBefore.match(/:icon\[[^\]]+\]\{([^}]*)$/);
      if (iconAttrMatch) {
        const typed = iconAttrMatch[1];
        const iconStyles = ['xs', 'small', 'large', 'xl', 'primary', 'secondary', 'success', 'warning', 'error', 'info', 'muted'];
        const filtered = iconStyles.filter(attr => 
          attr.toLowerCase().includes(typed.toLowerCase())
        );
        
        return {
          from: context.pos - typed.length,
          validFor: /^[\w-]*$/,  // Stay open while typing icon styles
          options: filtered.map(attr => ({
            label: attr,
            type: 'property',
            info: 'icon-style',
            render: renderAutocompleteItem(attr, 'property', 'icon-style'),
            apply: attr
          }))
        };
      }
      
      return null;
    }

    // Helper to get basic icon path for preview (simplified icons)
    function getIconPath(iconName) {
      const basicIcons = {
        'check': 'check-circle',
        'arrow': 'arrow-right',
        'heart': 'heart',
        'star': 'star',
        'home': 'home',
        'user': 'user',
        'settings': 'settings',
        'search': 'search',
        'bell': 'bell',
        'calendar': 'calendar',
        'file': 'file',
        'folder': 'folder',
        'mail': 'mail',
        'link': 'link',
        'image': 'image',
        'code': 'code',
        'zap': 'lightbulb',
      };
      
      // Try to map to known icon, or use first letter as fallback
      return basicIcons[iconName] || iconName.split('-')[0] || 'code';
    }

    // Bubble Menu - Floating toolbar for text selection
    let bubbleMenuVisible = false;

    // Add icons to bubble menu buttons
    function initBubbleMenu() {
      const buttons = bubbleMenu.querySelectorAll('.bubble-menu-button');
      buttons.forEach(btn => {
        const action = btn.dataset.action;
        btn.innerHTML = lucideIcon(action === 'heading' ? 'heading-1' : action);
      });
    }

    // Show bubble menu at selection
    function showBubbleMenu() {
      const selection = editor.state.selection.main;
      if (selection.empty || slashMenuActive) {
        hideBubbleMenu();
        return;
      }

      const from = Math.min(selection.from, selection.to);
      const to = Math.max(selection.from, selection.to);
      
      // Get coordinates of the selection
      const startCoords = editor.coordsAtPos(from);
      const endCoords = editor.coordsAtPos(to);
      
      if (!startCoords || !endCoords) {
        hideBubbleMenu();
        return;
      }

      // Position menu above the selection, centered
      const menuWidth = 200; // Approximate width
      const left = (startCoords.left + endCoords.left) / 2 - menuWidth / 2;
      const top = startCoords.top - 45; // 45px above the selection

      bubbleMenu.style.left = `${Math.max(10, left)}px`;
      bubbleMenu.style.top = `${Math.max(10, top)}px`;
      bubbleMenu.classList.add('active');
      bubbleMenuVisible = true;
    }

    // Hide bubble menu
    function hideBubbleMenu() {
      bubbleMenu.classList.remove('active');
      bubbleMenuVisible = false;
    }

    // Handle bubble menu actions
    function handleBubbleAction(action) {
      const selection = editor.state.selection.main;
      if (selection.empty) return;

      const from = Math.min(selection.from, selection.to);
      const to = Math.max(selection.from, selection.to);
      const selectedText = editor.state.doc.sliceString(from, to);

      let replacement;
      let cursorOffset = 0;

      switch (action) {
        case 'bold':
          replacement = `**${selectedText}**`;
          cursorOffset = replacement.length;
          break;
        case 'italic':
          replacement = `*${selectedText}*`;
          cursorOffset = replacement.length;
          break;
        case 'code':
          replacement = `\`${selectedText}\``;
          cursorOffset = replacement.length;
          break;
        case 'heading':
          // Add ## before the selection (or at start of line)
          const line = editor.state.doc.lineAt(from);
          const lineStart = line.from;
          replacement = selectedText;
          editor.dispatch({
            changes: { from: lineStart, to: lineStart, insert: '## ' }
          });
          hideBubbleMenu();
          return;
        case 'link':
          replacement = `[${selectedText}](url)`;
          cursorOffset = replacement.length - 4; // Position cursor at 'url'
          break;
        default:
          return;
      }

      editor.dispatch({
        changes: { from, to, insert: replacement },
        selection: { anchor: from + cursorOffset }
      });
      
      hideBubbleMenu();
    }

    // Bubble menu extension - Show on text selection
    const bubbleMenuExtension = EditorView.updateListener.of((update) => {
      if (update.selectionSet || update.docChanged) {
        // Small delay to let selection settle
        setTimeout(() => {
          const selection = update.view.state.selection.main;
          if (!selection.empty && !slashMenuActive) {
            showBubbleMenu();
          } else {
            hideBubbleMenu();
          }
        }, 50);
      }
    });

    // Syntax highlighting compartment - allows dynamic theme switching
    const syntaxHighlightCompartment = new Compartment();

    // Dark mode toggle functionality
    function initThemeToggle() {
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('taildown-editor-theme') || 'light';
      setTheme(savedTheme);
      updateThemeButton(savedTheme);
    }

    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('taildown-editor-theme', theme);
      
      // Update editor syntax highlighting if editor is initialized
      if (editor) {
        editor.dispatch({
          effects: syntaxHighlightCompartment.reconfigure(
            theme === 'dark' ? taildownDarkHighlightStyle : taildownHighlightStyle
          )
        });
      }
    }

    function updateThemeButton(theme) {
      themeToggleBtn.innerHTML = theme === 'dark' 
        ? lucideIcon('sun')  // Show sun icon in dark mode (to switch to light)
        : lucideIcon('moon'); // Show moon icon in light mode (to switch to dark)
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      setTheme(newTheme);
      updateThemeButton(newTheme);
    }

    // CodeMirror extension for slash commands with keymap priority
    const slashCommandExtension = [
      // High-priority keymap for slash menu navigation (runs before default keymaps)
      Prec.highest(keymap.of([
        {
          key: 'ArrowDown',
          run: (view) => {
            if (slashMenuActive) {
              navigateSlashMenu('down');
              return true;
            }
            return false;
          }
        },
        {
          key: 'ArrowUp',
          run: (view) => {
            if (slashMenuActive) {
              navigateSlashMenu('up');
              return true;
            }
            return false;
          }
        },
        {
          key: 'Tab',
          run: (view) => {
            if (slashMenuActive) {
              executeSelectedCommand();
              return true;
            }
            return false;
          }
        },
        {
          key: 'Escape',
          run: (view) => {
            if (slashMenuActive) {
              hideSlashMenu();
              return true;
            }
            return false;
          }
        }
      ])),
      // DOM event handlers for slash detection and filtering
      EditorView.domEventHandlers({
        keydown(event, view) {
          // Detect slash key at start of line or after space
          if (event.key === '/' && !slashMenuActive) {
            const pos = view.state.selection.main.head;
            const line = view.state.doc.lineAt(pos);
            const textBefore = line.text.slice(0, pos - line.from);
            
            // Only trigger if at start of line or after whitespace
            if (textBefore.trim() === '' || /\s$/.test(textBefore)) {
              slashMenuStart = pos;
              // Wait for next frame to show menu after "/" is inserted
              setTimeout(() => showSlashMenu(''), 0);
            }
          }
          return false;
        },
        
        input(event, view) {
          // Update slash menu with search text
          if (slashMenuActive && slashMenuStart !== null) {
            const pos = view.state.selection.main.head;
            const searchText = view.state.doc.sliceString(slashMenuStart + 1, pos);
            
            // Hide menu if user deletes the "/"
            if (pos <= slashMenuStart) {
              hideSlashMenu();
            } else {
              showSlashMenu(searchText);
            }
          }
          return false;
        }
      })
    ];

    // Initialize editor
    function initEditor() {
      try {
        // Get saved theme to determine initial syntax highlighting
        const savedTheme = localStorage.getItem('taildown-editor-theme') || 'light';
        const initialHighlightStyle = savedTheme === 'dark' ? taildownDarkHighlightStyle : taildownHighlightStyle;

        // Create editor with theme-aware syntax highlighting
        editor = new EditorView({
          doc: DEFAULT_TEMPLATE,
          extensions: [
            lineNumbers(),
            highlightActiveLineGutter(),
            history(),
            foldGutter(),
            indentOnInput(),
            bracketMatching(),
            closeBrackets(),
            autocompletion({
              override: [taildownAutocomplete],
              activateOnTyping: true,
              maxRenderedOptions: 10,
              closeOnBlur: true,
              icons: false,  // We're using custom rendering
              defaultKeymap: false  // Disable default keymap (includes Enter)
            }),
            highlightSelectionMatches(),
            taildown(),
            syntaxHighlightCompartment.of(initialHighlightStyle), // Theme-aware syntax highlighting
            slashCommandExtension, // Slash command menu
            bubbleMenuExtension, // Bubble menu for text selection
            // Custom autocomplete keybindings (Tab only, no Enter)
            Prec.highest(keymap.of([
              {
                key: 'Tab',
                run: acceptCompletion  // Accept completion
              },
              {
                key: 'Tab',
                run: indentWithTab.run  // If no completion, indent
              },
              {
                key: 'ArrowDown',
                run: moveCompletionSelection(true)  // Navigate down in autocomplete
              },
              {
                key: 'ArrowUp',
                run: moveCompletionSelection(false)  // Navigate up in autocomplete
              },
              {
                key: 'Escape',
                run: closeCompletion  // Close autocomplete menu
              }
            ])),
            keymap.of([
              ...defaultKeymap,
              ...historyKeymap,
              ...foldKeymap,
              ...closeBracketsKeymap,
              ...searchKeymap,
              ...lintKeymap,
              // Custom keybindings
              { key: 'Ctrl-s', run: () => { saveFile(); return true; } },
              { key: 'Cmd-s', run: () => { saveFile(); return true; } },
              { key: 'Ctrl-o', run: () => { openFile(); return true; } },
              { key: 'Cmd-o', run: () => { openFile(); return true; } },
              { key: 'Ctrl-e', run: () => { exportHTML(); return true; } },
              { key: 'Cmd-e', run: () => { exportHTML(); return true; } },
              { key: 'Ctrl-n', run: () => { newDocument(); return true; } },
              { key: 'Cmd-n', run: () => { newDocument(); return true; } },
              // Formatting shortcuts
              { key: 'Ctrl-b', run: () => { handleBubbleAction('bold'); return true; } },
              { key: 'Cmd-b', run: () => { handleBubbleAction('bold'); return true; } },
              { key: 'Ctrl-i', run: () => { handleBubbleAction('italic'); return true; } },
              { key: 'Cmd-i', run: () => { handleBubbleAction('italic'); return true; } },
              { key: 'Ctrl-k', run: () => { handleBubbleAction('link'); return true; } },
              { key: 'Cmd-k', run: () => { handleBubbleAction('link'); return true; } },
            ]),
            EditorView.updateListener.of((update) => {
              if (update.docChanged) {
                scheduleUpdate();
              }
            }),
          ],
          parent: editorPane,
        });

        // Initialize bubble menu
        initBubbleMenu();

        // Add bubble menu event listeners
        bubbleMenu.addEventListener('click', (e) => {
          const button = e.target.closest('.bubble-menu-button');
          if (button) {
            const action = button.dataset.action;
            handleBubbleAction(action);
          }
        });

        // Initialize theme toggle
        initThemeToggle();

        // Add theme toggle event listener
        themeToggleBtn.addEventListener('click', toggleTheme);

        // Try to restore from localStorage
        const saved = localStorage.getItem('taildown-editor-content');
        const savedFilename = localStorage.getItem('taildown-editor-filename');
        if (saved) {
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: saved }
          });
          if (savedFilename) {
            currentFilename = savedFilename;
            filenameDisplay.textContent = currentFilename;
          }
          // The editor's update listener will trigger updatePreview, so don't call it here
        } else {
          // Only call updatePreview if no saved content (template is already in editor)
          updatePreview(editor.state.doc.toString());
        }

        // Hide loading indicator
        loading.classList.add('hidden');

        console.log('✓ Taildown Editor initialized');
      } catch (error) {
        console.error('Failed to initialize editor:', error);
        loading.innerHTML = `<div style="color: var(--error)">Failed to load editor: ${error.message}</div>`;
      }
    }

    // Mermaid dynamic loading
    let mermaidLoaded = false;
    let mermaidLoading = false;

    /**
     * Intelligently resolve Mermaid path based on context
     * - file:// → Relative path to lib/mermaid.min.js
     * - localhost/127.0.0.1 → Absolute path from root
     * - Other domains → CDN fallback
     */
    function resolveMermaidPath() {
      const protocol = window.location.protocol;
      const hostname = window.location.hostname;
      
      if (protocol === 'file:') {
        // For file:// protocol, use relative path
        return './lib/mermaid.min.js';
      } else if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1') {
        // For localhost, use absolute path
        const basePath = window.location.pathname.replace(/\/[^\/]*$/, '');
        return `${basePath}/lib/mermaid.min.js`;
      } else {
        // For hosted/production, try relative first, fallback to CDN
        return './lib/mermaid.min.js';
      }
    }

    /**
     * Load Mermaid on-demand when diagrams are detected
     */
    async function ensureMermaidLoaded() {
      if (mermaidLoaded) return true;
      if (mermaidLoading) {
        // Wait for existing load
        return new Promise(resolve => {
          const check = setInterval(() => {
            if (mermaidLoaded || !mermaidLoading) {
              clearInterval(check);
              resolve(mermaidLoaded);
            }
          }, 50);
        });
      }

      mermaidLoading = true;
      try {
        const mermaidPath = resolveMermaidPath();
        
        // Use script tag loading (works with file:// protocol)
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = mermaidPath;
          script.onload = () => {
            // Initialize Mermaid (v11+ uses mermaid.default if ESM)
            if (window.mermaid) {
              const mermaidAPI = window.mermaid.default || window.mermaid;
              // Mermaid v11+ doesn't need explicit initialize, just set config
              if (typeof mermaidAPI === 'object' && mermaidAPI.run) {
                mermaidLoaded = true;
                console.log('✓ Mermaid loaded successfully');
                resolve();
              } else {
                reject(new Error('Mermaid API not found'));
              }
            } else {
              reject(new Error('Mermaid global not found'));
            }
          };
          script.onerror = () => reject(new Error('Failed to load script'));
          document.head.appendChild(script);
        });
      } catch (error) {
        console.warn('⚠ Failed to load Mermaid:', error);
        mermaidLoaded = false;
      } finally {
        mermaidLoading = false;
      }
      
      return mermaidLoaded;
    }

    // Schedule preview update (debounced)
    function scheduleUpdate() {
      clearTimeout(updateTimeout);
      updateTimeout = setTimeout(() => {
        const content = editor.state.doc.toString();
        updatePreview(content);
        // Auto-save to localStorage
        localStorage.setItem('taildown-editor-content', content);
        localStorage.setItem('taildown-editor-filename', currentFilename);
      }, 1000); // 1s debounce - only update when user pauses typing
    }

    // Update preview
    async function updatePreview(source) {
      try {
        const startTime = performance.now();
        
        // Save scroll position before updating
        let savedScrollTop = 0;
        let savedScrollLeft = 0;
        try {
          const previewDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
          if (previewDoc && previewDoc.documentElement) {
            savedScrollTop = previewDoc.documentElement.scrollTop || previewDoc.body.scrollTop || 0;
            savedScrollLeft = previewDoc.documentElement.scrollLeft || previewDoc.body.scrollLeft || 0;
          }
        } catch (e) {
          // Ignore if iframe not accessible yet
        }
        
        // Check if source contains Mermaid diagrams (both :::mermaid and ```mermaid syntax)
        const hasMermaid = /:::mermaid|```mermaid/i.test(source);
        if (hasMermaid) {
          await ensureMermaidLoaded();
        }
        
        const result = await compile(source, {
          inlineStyles: true,
          inlineScripts: true,
          darkMode: true,
        });
        const compileTime = performance.now() - startTime;

        // Function to restore scroll position
        const restoreScroll = () => {
          try {
            const previewDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            if (previewDoc && previewDoc.documentElement) {
              previewDoc.documentElement.scrollTop = savedScrollTop;
              previewDoc.body.scrollTop = savedScrollTop;
              previewDoc.documentElement.scrollLeft = savedScrollLeft;
              previewDoc.body.scrollLeft = savedScrollLeft;
            }
          } catch (e) {
            // Ignore if iframe not accessible
          }
        };

        previewFrame.srcdoc = result.html;
        statusBar.textContent = `✓ Compiled in ${compileTime.toFixed(0)}ms`;
        statusBar.className = 'success';
        
        // Inject and render Mermaid diagrams if present and loaded
        if (hasMermaid && mermaidLoaded) {
          previewFrame.addEventListener('load', async () => {
            try {
              const previewDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
              // Taildown compiles :::mermaid as component divs, ```mermaid as code blocks
              const mermaidComponents = previewDoc.querySelectorAll('[data-component="mermaid"], .component-mermaid');
              const mermaidCodeBlocks = previewDoc.querySelectorAll('code.language-mermaid');
              const mermaidBlocks = [...mermaidComponents, ...mermaidCodeBlocks];
              
              if (mermaidBlocks.length > 0) {
                // Inject Mermaid script into the preview iframe
                const mermaidPath = resolveMermaidPath();
                const script = previewDoc.createElement('script');
                script.src = mermaidPath;
                
                script.onload = async () => {
                  try {
                    // Get Mermaid from iframe context (handle both ESM and UMD)
                    let iframeMermaid = previewDoc.defaultView.mermaid;
                    
                    if (!iframeMermaid) {
                      console.warn('Mermaid not found in iframe');
                      return;
                    }
                    
                    // Handle ESM module format (with __esModule and default export)
                    if (iframeMermaid.__esModule && iframeMermaid.default) {
                      iframeMermaid = iframeMermaid.default;
                    }
                    
                    // Render each diagram
                    for (const block of mermaidBlocks) {
                      // Get source based on element type
                      const isComponent = block.hasAttribute('data-component') || block.classList.contains('component-mermaid');
                      let source;
                      
                      if (isComponent) {
                        // For :::mermaid components, source is in child <p> tag
                        const pTag = block.querySelector('p');
                        source = pTag ? pTag.textContent : block.textContent;
                      } else {
                        // For ```mermaid code blocks, source is direct text content
                        source = block.textContent;
                      }
                      
                      const id = 'mermaid-' + Math.random().toString(36).substr(2, 9);
                      
                      try {
                        const { svg } = await iframeMermaid.render(id, source);
                        
                        if (isComponent) {
                          // For components, replace the inner content but keep the container
                          block.innerHTML = svg;
                          block.classList.add('mermaid-rendered');
                        } else {
                          // For code blocks, replace the entire structure
                          const container = previewDoc.createElement('div');
                          container.className = 'mermaid-container';
                          container.innerHTML = svg;
                          block.parentElement.parentElement.replaceWith(container);
                        }
                      } catch (err) {
                        console.warn('Mermaid render error:', err);
                      }
                    }
                    
                    // Restore scroll position after Mermaid rendering
                    restoreScroll();
                  } catch (err) {
                    console.warn('Mermaid processing error:', err);
                    restoreScroll();
                  }
                };
                
                script.onerror = () => {
                  console.warn('Failed to load Mermaid script');
                  restoreScroll();
                };
                
                previewDoc.head.appendChild(script);
              } else {
                // No Mermaid blocks, just restore scroll
                restoreScroll();
              }
            } catch (e) {
              console.warn('Mermaid render failed:', e);
              restoreScroll();
            }
          }, { once: true });
        } else {
          // No Mermaid at all, restore scroll after iframe loads
          previewFrame.addEventListener('load', () => {
            restoreScroll();
          }, { once: true });
        }
      } catch (error) {
        statusBar.textContent = `✗ Error: ${error.message}`;
        statusBar.className = 'error';
        console.error('Compilation error:', error);
      }
    }

    // New document
    function newDocument() {
      if (confirm('Create new document? Any unsaved changes will be lost.')) {
        // Start with a truly blank document
        const blankContent = '# New Document\n\n';
        editor.dispatch({
          changes: { from: 0, to: editor.state.doc.length, insert: blankContent }
        });
        currentFilename = 'untitled.td';
        currentFileHandle = null;
        filenameDisplay.textContent = currentFilename;
        localStorage.removeItem('taildown-editor-content');
        localStorage.removeItem('taildown-editor-filename');
      }
    }

    // Show welcome template
    function showTemplate() {
      const currentContent = editor.state.doc.toString();
      const hasContent = currentContent.trim().length > 0 && currentContent !== '# New Document\n\n';
      
      if (hasContent && !confirm('Load welcome template? Any unsaved changes will be lost.')) {
        return;
      }
      
      editor.dispatch({
        changes: { from: 0, to: editor.state.doc.length, insert: DEFAULT_TEMPLATE }
      });
      currentFilename = 'welcome.td';
      currentFileHandle = null;
      filenameDisplay.textContent = currentFilename;
      // Don't clear localStorage - this is just a preview
    }

    // Open file
    async function openFile() {
      try {
        if ('showOpenFilePicker' in window) {
          // Modern File System API
          const [fileHandle] = await window.showOpenFilePicker({
            types: [{
              description: 'Taildown Files',
              accept: { 'text/plain': ['.td', '.taildown'] }
            }],
            multiple: false
          });
          const file = await fileHandle.getFile();
          const content = await file.text();
          
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: content }
          });
          
          currentFileHandle = fileHandle;
          currentFilename = file.name;
          filenameDisplay.textContent = currentFilename;
          
          statusBar.textContent = `✓ Opened ${currentFilename}`;
          statusBar.className = 'success';
        } else {
          // Fallback: traditional file input
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.td,.taildown';
          input.onchange = async (e) => {
            const file = e.target.files[0];
            if (file) {
              const content = await file.text();
              editor.dispatch({
                changes: { from: 0, to: editor.state.doc.length, insert: content }
              });
              currentFilename = file.name;
              currentFileHandle = null;
              filenameDisplay.textContent = currentFilename;
              statusBar.textContent = `✓ Opened ${currentFilename}`;
              statusBar.className = 'success';
            }
          };
          input.click();
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          statusBar.textContent = `✗ Error opening file: ${error.message}`;
          statusBar.className = 'error';
          console.error('Error opening file:', error);
        }
      }
    }

    // Save file
    async function saveFile() {
      try {
        const content = editor.state.doc.toString();
        
        if (currentFileHandle && 'createWritable' in currentFileHandle) {
          // File System API save
          const writable = await currentFileHandle.createWritable();
          await writable.write(content);
          await writable.close();
          statusBar.textContent = `✓ Saved ${currentFilename}`;
          statusBar.className = 'success';
        } else if ('showSaveFilePicker' in window) {
          // Show save dialog
          const fileHandle = await window.showSaveFilePicker({
            types: [{
              description: 'Taildown Files',
              accept: { 'text/plain': ['.td'] }
            }],
            suggestedName: currentFilename
          });
          const writable = await fileHandle.createWritable();
          await writable.write(content);
          await writable.close();
          currentFileHandle = fileHandle;
          currentFilename = (await fileHandle.getFile()).name;
          filenameDisplay.textContent = currentFilename;
          statusBar.textContent = `✓ Saved ${currentFilename}`;
          statusBar.className = 'success';
        } else {
          // Fallback: download
          downloadFile(content, currentFilename);
        }
        
        // Also save to localStorage
        localStorage.setItem('taildown-editor-content', content);
        localStorage.setItem('taildown-editor-filename', currentFilename);
      } catch (error) {
        if (error.name !== 'AbortError') {
          statusBar.textContent = `✗ Error saving: ${error.message}`;
          statusBar.className = 'error';
          console.error('Error saving file:', error);
        }
      }
    }

    // Download file
    function downloadFile(content, filename) {
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      statusBar.textContent = `✓ Downloaded ${filename}`;
      statusBar.className = 'success';
    }

    // Export HTML
    async function exportHTML() {
      try {
        const source = editor.state.doc.toString();
        
        // Check if source contains Mermaid diagrams
        const hasMermaid = source.includes(':::mermaid');
        
        const result = await compile(source, {
          inlineStyles: true,
          inlineScripts: true,
          darkMode: true,
        });
        
        let finalHtml = result.html;
        
        // If Mermaid diagrams exist, get rendered SVGs from preview iframe
        if (hasMermaid) {
          const previewDoc = previewFrame.contentDocument;
          if (previewDoc) {
            const mermaidElements = previewDoc.querySelectorAll('[data-component="mermaid"], .component-mermaid');
            
            if (mermaidElements.length > 0) {
              // Create a temporary div to parse the compiled HTML
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = finalHtml;
              
              // Find mermaid elements in the compiled HTML
              const compiledMermaidElements = tempDiv.querySelectorAll('[data-component="mermaid"], .component-mermaid');
              
              // Replace each mermaid element with its rendered SVG
              mermaidElements.forEach((renderedElement, index) => {
                const svg = renderedElement.querySelector('svg');
                if (svg && compiledMermaidElements[index]) {
                  // Keep the wrapper div but replace its content with the rendered SVG
                  compiledMermaidElements[index].innerHTML = svg.outerHTML;
                }
              });
              
              finalHtml = tempDiv.innerHTML;
            }
          }
        }
        
        const htmlFilename = currentFilename.replace(/\.td$/, '.html');
        downloadFile(finalHtml, htmlFilename);
        statusBar.textContent = `✓ Exported ${htmlFilename}`;
        statusBar.className = 'success';
      } catch (error) {
        statusBar.textContent = `✗ Export failed: ${error.message}`;
        statusBar.className = 'error';
        console.error('Export error:', error);
      }
    }

    // Draggable divider
    let startX = 0;
    let startY = 0;
    let startEditorPercent = 0;

    divider.addEventListener('mousedown', (e) => {
      isDragging = true;
      divider.classList.add('dragging');
      
      const container = document.getElementById('editor-container');
      const isVertical = window.innerWidth <= 768;
      
      // Disable pointer events on iframe to prevent it from capturing mouse events
      previewFrame.style.pointerEvents = 'none';
      // Prevent text selection during drag
      document.body.style.userSelect = 'none';
      document.body.style.cursor = isVertical ? 'row-resize' : 'col-resize';
      
      // Store the starting position and current editor percentage
      if (isVertical) {
        startY = e.clientY;
        const containerHeight = container.getBoundingClientRect().height;
        const editorHeight = editorPane.getBoundingClientRect().height;
        startEditorPercent = (editorHeight / containerHeight) * 100;
      } else {
        startX = e.clientX;
        const containerWidth = container.getBoundingClientRect().width;
        const editorWidth = editorPane.getBoundingClientRect().width;
        startEditorPercent = (editorWidth / containerWidth) * 100;
      }
      
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const container = document.getElementById('editor-container');
      const isVertical = window.innerWidth <= 768;
      
      if (isVertical) {
        // Calculate the new percentage based on mouse movement
        const containerHeight = container.getBoundingClientRect().height;
        const deltaY = e.clientY - startY;
        const deltaPercent = (deltaY / containerHeight) * 100;
        const newPercent = startEditorPercent + deltaPercent;
        
        // Allow resizing between 15% and 85%
        if (newPercent >= 15 && newPercent <= 85) {
          editorPane.style.flex = `0 0 ${newPercent}%`;
        }
      } else {
        // Calculate the new percentage based on mouse movement
        const containerWidth = container.getBoundingClientRect().width;
        const deltaX = e.clientX - startX;
        const deltaPercent = (deltaX / containerWidth) * 100;
        const newPercent = startEditorPercent + deltaPercent;
        
        // Allow resizing between 15% and 85%
        if (newPercent >= 15 && newPercent <= 85) {
          editorPane.style.flex = `0 0 ${newPercent}%`;
        }
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        divider.classList.remove('dragging');
        
        // Re-enable pointer events and restore cursor
        previewFrame.style.pointerEvents = '';
        document.body.style.userSelect = '';
        document.body.style.cursor = '';
      }
    });

    // Touch events for mobile support
    divider.addEventListener('touchstart', (e) => {
      isDragging = true;
      divider.classList.add('dragging');
      
      const container = document.getElementById('editor-container');
      const isVertical = window.innerWidth <= 768;
      
      // Disable pointer events on iframe to prevent it from capturing touch events
      previewFrame.style.pointerEvents = 'none';
      // Prevent text selection during drag
      document.body.style.userSelect = 'none';
      
      const touch = e.touches[0];
      
      // Store the starting position and current editor percentage
      if (isVertical) {
        startY = touch.clientY;
        const containerHeight = container.getBoundingClientRect().height;
        const editorHeight = editorPane.getBoundingClientRect().height;
        startEditorPercent = (editorHeight / containerHeight) * 100;
      } else {
        startX = touch.clientX;
        const containerWidth = container.getBoundingClientRect().width;
        const editorWidth = editorPane.getBoundingClientRect().width;
        startEditorPercent = (editorWidth / containerWidth) * 100;
      }
      
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      
      const container = document.getElementById('editor-container');
      const isVertical = window.innerWidth <= 768;
      const touch = e.touches[0];
      
      if (isVertical) {
        // Calculate the new percentage based on touch movement
        const containerHeight = container.getBoundingClientRect().height;
        const deltaY = touch.clientY - startY;
        const deltaPercent = (deltaY / containerHeight) * 100;
        const newPercent = startEditorPercent + deltaPercent;
        
        // Allow resizing between 15% and 85%
        if (newPercent >= 15 && newPercent <= 85) {
          editorPane.style.flex = `0 0 ${newPercent}%`;
        }
      } else {
        // Calculate the new percentage based on touch movement
        const containerWidth = container.getBoundingClientRect().width;
        const deltaX = touch.clientX - startX;
        const deltaPercent = (deltaX / containerWidth) * 100;
        const newPercent = startEditorPercent + deltaPercent;
        
        // Allow resizing between 15% and 85%
        if (newPercent >= 15 && newPercent <= 85) {
          editorPane.style.flex = `0 0 ${newPercent}%`;
        }
      }
      
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
        divider.classList.remove('dragging');
        
        // Re-enable pointer events
        previewFrame.style.pointerEvents = '';
        document.body.style.userSelect = '';
      }
    });

    // Button event listeners
    newBtn.addEventListener('click', newDocument);
    openBtn.addEventListener('click', openFile);
    saveBtn.addEventListener('click', saveFile);
    downloadBtn.addEventListener('click', () => {
      const content = editor.state.doc.toString();
      downloadFile(content, currentFilename);
    });
    exportBtn.addEventListener('click', exportHTML);
    helpBtn.addEventListener('click', showTemplate);

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initEditor);
    } else {
      initEditor();
    }

    // Warn before closing with unsaved changes
    window.addEventListener('beforeunload', (e) => {
      const current = editor?.state.doc.toString();
      const saved = localStorage.getItem('taildown-editor-content');
      if (current && current !== saved) {
        e.preventDefault();
        e.returnValue = '';
      }
    });
  </script>
</body>
</html>

